# 파이썬 4주차
## 함수
- 함수는 `def 키위드`를 사용하여 정의
- 아래와 같은 형식으로 정의되어야 한다.
```python
def 함수이름(매개변수)
    print('함수의 내용')
    print('들여쓰기 해야함')    # PEP에서는 4칸 들여쓰기가 
    return output
```

- 함수는 출력을 반환 혹은 반환하지 않을 수 있다.
- 이때는 return을 쓰지 않으며 `반환값은 None` 이다.
```python
def 함수이름(매개변수)  # None을 반환
    print('함수의 내용')
```
- 함수를 사용하면 아래와 같은 이점있다.
    - 코드의 중복 줄이기
    - 복잡한 작업 나누기
    - 구현 세부 정보 숨기기
    - 가독성 향상
    - 추적성 향상

## 지역, 비지역, 전역
- `영역에 따라 변수의 값이 다를 수 있다.`
- 각 다른 지역을 벗어난 변수는 전의 값이 아닌 해당 지역의 값을 가지게 된다.
```python
def outer():
    test = 1        # 바깥 영역 test = 1
    def inner():
        test = 2    # 지역 test = 2
        print('inner:', test)
    inner()
    print('outer:', test)
test = 0            # 전역 test = 0
outer()
print('global:', test)
```
> inner: 2  
> outer: 1  
> global: 0

- `nonlocal 키워드`를 사용하면 outer 영역에서도 지역 값을 유지시킬 수 있다.
```python
def outer():
    test = 1
    def inner():
        nonlocal test       # 이를 사용해 바깥 영역도 지역값 유지
        test = 2            # 지역 test = 2
        print('inner:', test)
    inner()
    print('outer:', test)   # 1이 아닌 2가 출력
test = 0                    # 전역 test = 0
outer()
print('global:', test)
```
   #### nonlocal은 전역외의 enclosing 지역에만 적용된다.

- `gobal 키워드`를 사용하면 해당 지역의 변수가 아닌 전역 변수 사용 가능하다

```python
def outer():
    test = 1        # outer scope
    def inner():
        global test
        test = 2    # global scope
        print('inner:', test)
    inner()
    print('outer:', test)

test = 0            # global scope
outer()
print('global:', test)  # inner() 에서 test=2 했으므로 2 출력
```
> 2  
> 1  
> 2

## 매개변수
- 함수 내에서 인수 이름에 객체를 할당해도 영향을 미치지 않는다.
    - 전역, 지역 변수가 이름이 같아도 `지역변수가 변경되도 전역변수에 영향이 없다.`

- 함수에서 변경 가능한 객체 인수를 변경하면 호출자가 영향을 받는다.
    - 지역 안에서 전역 배열의 인자를 변경하면 전역에 영향 
```python
x = [1, 2, 3]
def func(x):
    x[1] = 42 # 전역 배열 x에도 영향을 줌
    x = 'something else' # x는 새 객체인 문자열 가리킴
    print(x)
func(x)
print(x) # still prints: [1, 42, 3]
```
> something else  
> [1, 42, 3]

- `call-by-value`로 전달
    #### 파이썬은 `연산 등을 통해 변수가 가지는 값이 `변경되더라도 실제 메모리에 저장됭 값이 변경되는 것이 아니라 `가르키고 있는 인스턴스가 변경`된다.(마치 call-by-reference 처럼)

- 콤마(,)를 사용하여 여러 인자를 전달 가능
```python
def func(a, b, c)
```

- 인자의 초기값 설정가능
```python
def func(a=1, b=2, c=3)
```
   #### `이때 파라매터 초기값은 맨 우측 부터 설정해야한다.`

## 다양한 수의 위치 지정 인수 전달
- 파이썬은 다양한 수의 위치 지정 인수를 함수에 전달 가능
```python
def minimum(*n):    # n은 튜플이다.
    if n:           # n이 비지 않을때 True, 반대는 False
        mn = n[0]
        for value in n[1:]:
            if value < mn:
                mn = value
        print(mn)
minimum(1, 3, -7, 9)
minimum()
```
> -7
> # 아무것도 출력 안함

- 매개변수에 `*을 사용`하여 튜플을 unpacking 가능
```python
def func(*args):
    print(args)
values = (1, 3, -7, 9)
func(values)
func(*values)
```
> ((1, 3, -7, 9),)  
> (1, 3, -7, 9)

## 변수 키워드 인수
- 가변매개 변수 사용 가능
    - **구문을 사용, 이를 이용하여 사전의 압축 풀기 가능
```python
def func(**kwargs):
    print(kwargs)
func(a=1, b=42)
func(**{'a': 1, 'b': 42})
func(**dict(a=1, b=42))
```
> {'a': 1, 'b': 42}  
> {'a': 1, 'b': 42}  
> {'a': 1, 'b': 42}

   나중에 위를 아래와 같이 응용도 가능
```python
def connect(**options):
    conn_params = {
    'host': options.get('host', '127.0.0.1'),
    'port': options.get('port', 5432),
    'user': options.get('user', ''),
    'pwd': options.get('pwd', ''),
    }
    print(conn_params)
connect()
connect(host='127.0.0.42', port=5433)
connect(port=5431, user='fab', pwd='gandalf')
```
> {'host': '127.0.0.1', 'port': 5432, 'user': '', 'pwd': ''}  
> {'host': '127.0.0.42', 'port': 5433, 'user': '', 'pwd': ''}  
> {'host': '127.0.0.1', 'port': 5431, 'user': 'fab', 'pwd': 'gandalf'}

## 키워드 전용 매개 변수
- 함수를 사용할 때 이 매개변수는 해당 파라매터에 매칭이 되는 것을 명시한다.
```python
def func(a=5, b=4):
    print(b)
func(1)     # a=1, b=4로 파라매터 패싱
func(b=1)   # 이렇게 func() 에서 b로 넘어갈 값 명시
```
> 4  
> 1  

   또다른 예:
```python
def kwo(*a, c):
    print(a, c)
kwo(1, 2, 3, c=7) # prints: (1, 2, 3) 7
kwo(c=4)
# kwo(1, 2) # breaks, invalid syntax, with the following error
                    # TypeError: kwo() missing 1 required keyword-only argument: 'c'
def kwo2(a, b=42, *, c):
    print(a, b, c)
kwo2(3, b=7, c=99)  # prints: 3 7 99
kwo2(3, c=13)       # prints: 3 42 13
# kwo2(3, 23) # 이 문장은 신텍스 에러
```

# 혼합 input 매개변수
- 매개 변수를 혼합해서 사용 가능하다.
```python
def func(a, b, c=7, *args, **kwargs):
    print('a, b, c:', a, b, c)
    print('args:', args)
    print('kwargs:', kwargs)
func(1, 2, 3, *(5, 7, 9), **{'A': 'a', 'B': 'b'}) # a, b, *args, 
func(1, 2, 3, 5, 7, 9, A='a', B='b') # 같은 결과
```
> a, b, c: 1 2 3  
> args: (5, 7, 9)  
> : {'A': 'a', 'B': 'b'}  
> a, b, c: 1 2 3  
> : (5, 7, 9)  
> kwargs: {'A': 'a', 'B': 'b'}

- 매개 변수를 넘겨줄때 매칭되는 매개변수를 명시하면 함수 호출시 넘겨주는 매개변수의 순서는 상관없다.
```python
def func_with_kwonly(a, b=42, *args, c, d=256, **kwargs):
    print('a, b:', a, b)
    print('c, d:', c, d)
    print('args:', args)
    print('kwargs:', kwargs)
func_with_kwonly(3, 42, c=0, d=1, *(7, 9, 11), e='E', f='F') # c, d, *args의 위치 변경 및 명시
func_with_kwonly(3, 42, *(7, 9, 11), c=0, d=1, e='E', f='F') # 일반적인 파라매터 패싱
```
> a, b: 3 42  
> c, d: 0 1  
> args: (7, 9, 11)  
> kwargs: {'e': 'E', 'f': 'F'}  
> a, b: 3 42  
> c, d: 0 1  
> args: (7, 9, 11)  
> kwargs: {'e': 'E', 'f': 'F'}

## 변경가능한 기본
- 같은 함수에 대한 후속 호출은 디폴트 값의 가변성에 따라 다르게 동작한다.
```python
def func(a=[], b={}):
    print(a)
    print(b)
    print('#' * 12)
    a.append(len(a)) # this will affect a's default value
    b[len(a)] = len(a) # and this will affect b's one
func()
func()
func()
```
> []  
> {}  
> ############  
> [0]  
> {1: 1}  
> ############  
> [0, 1]  
> {1: 1, 2: 2}  
> ############

   그러나 중간에 매개변수를 넣어 함수 호출하면
```python
func()
func(a=[1, 2, 3], b={'B': 1})
func()
```
> []  
> {}  
> ############  
> [1, 2, 3]  
> {'B': 1}  
> ############  
> [0]  
> {1: 1}  
> ############

## 반환값
- 파이썬은 튜플도 반환이 가능하다.
- 다른 언어는 {}로 함수의 범위를 나타낼 수 있으나 파이썬은 없기때문에 pass(null 연산자)와 같은 명령문이 필요하다.