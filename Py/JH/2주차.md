# 파이썬 2주차

## 변수, 상수

- 변수의 값을 바꿀면 전의 id와 후의 id가 다름
- 그러나 클래스 안의 멤버 변수의 값을 변경하면 id는 전후 동일
- 숫자는 상수 즉, 변경 불가

## - 연산자

- 파이썬은 2개의 연산자가 있다. 연산자는 2개로 나누어진다.

실수 나누기(/) | 정수 나누기(//)
:---: | :---:
7 / 4 - 1.75 | 7 // 4 = 1
-7 / 4 = -1.75 | -7 // 4 = -2

- 파이썬에서 정수 나누기의 결과는 음쪽으로 반올림 된다.
- 우리가 생각하는 정수값의 결과가 나오려면 아래와 같아야한다.
> int(1.75) = 1  
> int(-1.75) = -1

- %연산자는 나눗셈의 나머지를 계산  

## - 부울형

- 참, 거짓을 나타내는 자료형
- 부울은 정수의 하위 클래스이며 0, 1 처럼 동작
- 0 : 거짓
- 음수, 1 : 참

```python
bool(-42)           # true  
bool(0)             # false  
True and False      # False  
True or False       # True  
True + 1            # 2  
False + 42          # 42
```

## - 실수

- 실수의 부동 소수점 숫자는 IEEE 754 배정도 부동 소수점 형식에 따라 표현
- 최대 2 ** 64 == 18,446,744,073,709,551,616 숫자를 해당 비트 수로 나타낼 수 있습니다.
- 모든 실수를 정확히 나타내기 불가 => 근사값으로 나타냄

> 3 * 0.1 – 0.3  => 5.551115123125783e-17

- 위에서 0이 나와야하는데 근사값으로 나옴

- 따라서 파이선은 부동 소수점을 정확하게 표현하기 위해 Decimal 타입을 제공함

```python
from decimal import Decimal
D(0.1) * D(3) - D(0.3)      # Decimal('2.775557561565156540423631668E-17')  
D('0.1') * D(3) - D('0.3')  # Decimal('0.0')  

Decimal('3.14') == Decimal('3.140000000000000124344978758017532527446746826171875') # false
```

- 파이썬은 허수 같은 복잡한 숫자도 지원한다

```python
c = 3.14 + 2.73j  
c.real          # 3.14  
c.imag          # 2.73 허수 부분

c * 2           # 6.28+5.46j
c ** 2          # 2.4067000000000007+17.1444j

d = 1 + 1j      # 덧셈, 뺄셈 가능  
c - d           # (2.14+1.73j)  

c.conjugate()   # A + Bj를 A - Bj로 바꿈 따라서 3.14-2.73j
```

## - 분수, 소수

- 분수

```python
from fractions import Fraction

Fraction(1, 3) + Fraction(2, 3) => 1/3 + 2/3 = 1/1  # Fraction(1, 1)  
f = Fraction(10, 6)
f.numerator             # 5  
f.denominator           # 3
```

---

## 변경 불가능한 시퀸스

### - 스트링과 바이트

- 파이썬은 다른 언어와 달리 char형이 없으므로 단일 문자는 길이가 1인 문자열로 처리된다.
- 문자열을 표현하는 법은 아래와 같다.

```python
'이걸로도 문자열 출력'
"기본적인 문자열 출력"
'''이것을 사용하면 중간에 개행해도  
    긴 문자열 처리가능.'''
'\n을 쓰면 c, c++처럼 개행 가능'
```

- len() 함수를 쓰면 문자열 길이 알아내기 가능

```python
str1 = '안녕'  
print(len(str1))  # 2
```

## - 인코딩, 디코딩 스트링

- 인 코드 / 디코드 메서드를 사용하여 유니코드 문자열을 인코딩하고 바이트 객체를 디코딩 할 수 있다.
- 문자열 선언 앞에 문자 'b'를 추가하여 byte 객체를 만들 수 있다.

## - 문자열 인덱싱 및 분할

- 문자열에서 인덱스로 특정 문자 지정 가능

```python
s = "The trouble is you think you have time."  
s[0]         # 'T'  
s[:4]        # 'The '  
s[4:]        # 'trouble is you think you have time.'  
s[2:14]      # 'e trouble is'
s[2:14:3]    # 'erb '
s[:]         # "The trouble is you think you have time."
```

## - 튜플 자료형

- 튜플은 임의의 파이썬 객체의 시퀸스이다.
- 리스트와 비슷한 역활을 한다
- 그러나 요소 뒤에 콤마를 반드시 필요로 한다.
- 또한 튜플 안의 항목값은 변경할 수 없다.
- 튜플은 두 변수를 swap 할때 한줄에 처리 가능하다.

```python
t = (1, 2, 3, 4,)
a, b = 1, 2  
a, b = b, a  # 스왑됨 b=1, a=2
```

---

## 변경 가능한 시퀸스

### - 리스트

- string, int형에 상관 없이 저장가능

```python
a = [1, 2, 3, 4]  
b = ['hello']
```

- list() 사용한 리스트는

```python
string_example = list('hello')  
print(a)        # ['h', 'e', 'l', 'l', 'o']
```

- .append() 를 사용하여 리스트 맨 뒤에 요소 삽입가능

```python
a = [1, 2, 3]  
a.append(4)
print(a)        # [1, 2, 3, 4]

a = list('hi')  
a.append(' hello')  
print(a)        #['h', 'i', ' hello']
```

- .count()로 리스트 안에 원하는 숫자가 얼만큼 있는지 확인

```python
a = [1, 2, 3, 1]  
a.count(1)      # 1이 몇개 있는지 찾기  즉, 2출력
```

- .extend()로 리스트 뒤로 요소 붙이기 가능

```python
a = [1, 2, 3]  
a.extend(4, 5)  # a = [1, 2, 3, 4, 5]
```

- .index() 으로 원하는 요소의 인덱스상 위치 반환

```python
a = [1, 2, 3]  
a.index(3)      # 3이 있는 인덱스 반환 즉, 2 출력
```

- .insert() 으로 원하는 위치에 삽입가능

```python
a = [1, 2, 3]  
a.insert(0, 4)  #a = [4, 1, 2, 3]
```

- .pop() 으로 원하는 인덱스 위치의 요소 pop 가능

```python
a = [1, 2, 3]  
a.pop(1) # 인덱스상 1위치인 2가 pop  
a => [1, 3]
```

- .remove() 으로 원하는 값을 가진 요소 **한번** 제거함

```python
a = [1, 2, 1, 3]  
a.remove(1)     # 리스트 앞에서 부터 1찾아서 찾으면 **한번** 제거  
                # a = [2, 1, 3]
```

- .reverse() 로 리스트 뒤집기 가능
- .sort() 로 오름차순으로 정렬
- min(), max() 로 최소 최대 값 찾기 가능
- +로 리스트 연결, *로 반복된 리스트로 만들 수 있음

```python
a = [1, 2, 3]
b = [4, 5, 6]  
a + b           # [1, 2, 3, 4, 5, 6]  
a * 2           # [1, 2, 3, 1, 2, 3]
```

## 바이트 배열

- 바이트 값을 저장하는 버퍼 오브젝트
  - [ : 포함되어 있음
  - ) : 포함 안되어 있음
  > [0, 256) 이것은 0~255 중 하나

- 바이트 배열은 요소의 값 변경 가능
- 문자열로 바이트 배열 만들려면 문자열 앞에 b를 붙여줘야함
- 정수의 경우 0~255 사이의 정수 값이여야함

- .replace() 로 재배치 가능

```python
name = bytearray(b'Lina')  
name.replace(b'L', b'l')    # bytearray(b'lina')
```

- .upper() 로 대문자로

```python
name = bytearray(b'Lina')  
print(name.upper())         # bytearray(b'LINA') 출력
```

- .count() 해당 문자열 개수 만환

```python
name = bytearray(b'LinaLLlll')
print(name.count(b'Li'))    # 1
```
